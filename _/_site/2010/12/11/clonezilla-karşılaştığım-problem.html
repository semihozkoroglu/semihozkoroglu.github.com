<!DOCTYPE html>
<html lang="tr">

<head>
<meta charset="utf-8">

<title>Semih Özköroğlu - Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="author" content="">

<link rel="shortcut icon" href="/assets/css/favicon.ico">

<!-- Le Styles -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet">
<link href="/assets/css/skeleton.css" rel="stylesheet">
<link href="/assets/css/layout.css" rel="stylesheet">

<!-- Le Fonts -->
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700" rel="stylesheet">
<link href="/assets/css/fonts/glyphicons/style.css" rel="stylesheet">
</head>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44643779-1', 'semihozkoroglu.github.io');
  ga('send', 'pageview');

</script>
<body>

  <!-- Color Customizer, remove if not needed -->
  <div id="joiee-customizer"></div>

  <div id="main-wrapper" class="wide">

    <!-- Main Header -->
    <header id="main-header">

      <!-- Top Header -->
      <div id="header-top">
        <div class="container">
          <div class="sixteen columns">

            <!-- Logo Container -->
            <div id="logo-container">
              <div id="logo-center">
                <a href="/index.html">
                  <img src="/assets/img/logo.png" alt="Sem">
                </a>
              </div>
            </div>
            <!-- END Logo Container -->

            <div class="tagline">Android Developer</div>

            <!-- Main Navigation -->
            <nav id="main-nav">
              <table border="0">
                <tr>
                  <td>
                    <div id="img" onClick="displayMenu()"
                        class="circle" style="background-image: 
                        url('/assets/img/sem.jpg')">
                    </div>
                    <!-- <div id="img2" style="display:none;" onClick="displayMenu()"
                        class="circle" style="background-image: 
                        url('/assets/img/sem.jpg')">
                    </div> -->
                  </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="https://github.com/semihozkoroglu">
                        <div class="icos-github">
                        </div>
                      </a>
                    </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="https://plus.google.com/105208314074645610795">
                        <div class="icos-google">
                        </div>
                      </a>
                    </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="https://www.facebook.com/semiiiih">
                        <div class="icos-facebook">
                        </div>
                      </a>
                    </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="http://www.linkedin.com/profile/view?id=181945022">
                        <div class="icos-linkedin">
                        </div>
                      </a>
                    </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="https://twitter.com/semihozkoroglu">
                        <div class="icos-twitter">
                        </div>
                      </a>
                    </td>
                  
                    <td>
                      <a style="margin-right:5px;" href="http://www.youtube.com/channel/UCGMOH3R6gUxE9optqiSHUBw">
                        <div class="icos-youtube">
                        </div>
                      </a>
                    </td>
                  
                </tr>
              </table>
            </nav>
            <!-- END Main Navigation -->
          </div>
        </div>
      </div>

      <!-- Bottom Header -->
    </header>
    <!-- END Main Header -->

    <!-- Main Content -->
    <section id="main-content">

      <div class="container">

        <div id="header-bottom">
          <div class="container">
            <div class="sixteen columns">
              <ul class="breadcrumb">
                <li><a href="/index.html">Home</a><span class="divider">/</span></li>
                <li style="color:#ff5700">Blog</li>
              </ul>
            </div>
          </div>
        </div>

        <aside class="four columns sidebar">
          <section class="sidebar-section">
            <div class="underline-heading">
	<h3>Posts</h3>
</div>
<ul class="arrow-list">
    
        <li>
            <a style="color:#a4a4a4; font-size:15px;" href="/2013/12/15/scrollview-custom-scrollbar.html">Scrollview Custom Scrollbar</a>
        </li>
    
        <li>
            <a style="color:#a4a4a4; font-size:15px;" href="/2013/10/06/jira-install-amazon.html">How to install Jira on Linux Amazon EC2 server</a>
        </li>
    
        <li>
            <a style="color:#a4a4a4; font-size:15px;" href="/2013/09/23/git-kullanim.html">Source Tree ile Git Kullanımı</a>
        </li>
    
        <li>
            <a style="color:#a4a4a4; font-size:15px;" href="/2013/09/23/git-flow.html">Git Flow Akışı ve Source Tree</a>
        </li>
    
        <li>
            <a style="color:#a4a4a4; font-size:15px;" href="/2012/07/23/huawei-modem.html">Huawei E177 modem'in Ubuntu 11.10 'a tanıtılması</a>
        </li>
    
</ul>
<div class="read-more">
    <a href="/posts.html">Show more >></a>
</div>
            <div class="underline-heading">
	<h3>Tags</h3>
</div>
<ul class="tag-labels">
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/<p>Endüstri labında clonezilla ile imajı alıp diğer bilgisayarlara sistemi kopyalıyordum.
Ancak iki tanesinde problemle karşılaştım.Şunu da belirtim sistemlerin hepsi aynı yani lenovanın
sıfır bilgisayarlar ancak bir tanesinde ekran bozuklugu var yani görüntü bios&#39;a girdiğimde de kötü ve sistemler açılırken
kilitleniyor.Bundaki durumu ekran kartı sıkıntılıdır şeklinde düşünmüştüm ama diğerindeki durum gerçekten ilginc
imajın bulundugu diskten başlattıgımda açılıyor ama kendi diskine kopyalamayı yaptıktan sonra windows açılırken logo&#39;da,
ubuntu ise siyah ekranda çakılıp kalıyor donanımsal bir problemin olması muhtemel.Bu durumun çözümünü buldugumda burada paylaşıcam.
Harici diskten başlattığımda açılıp kendi diskinden açılmamasının nedenini anlyabilirsem durum çözülmüş olur sanırım.</p>

<p>Bu yazımın altında devam ediyorum..İşletim sistemlerinin açlırken donmasının ve sadece güvenli modda açmasının sebebi
ekran kartı arızalı oldugundan dolayı imişş.Çünkü güvenli modda açabiliyorsa harddiskin sağlam olduğu ortada ve cd&#39;den kuruluma başlarkende aynı durumlarla
karşılaşınca ekran kartında problem olma olasılığı maximum dereceye ulaşmıştı.Basit bir denemeyle kendisini ele verdi zaten..</p>
" title="<p>Endüstri labında clonezilla ile imajı alıp diğer bilgisayarlara sistemi kopyalıyordum.
Ancak iki tanesinde problemle karşılaştım.Şunu da belirtim sistemlerin hepsi aynı yani lenovanın
sıfır bilgisayarlar ancak bir tanesinde ekran bozuklugu var yani görüntü bios&#39;a girdiğimde de kötü ve sistemler açılırken
kilitleniyor.Bundaki durumu ekran kartı sıkıntılıdır şeklinde düşünmüştüm ama diğerindeki durum gerçekten ilginc
imajın bulundugu diskten başlattıgımda açılıyor ama kendi diskine kopyalamayı yaptıktan sonra windows açılırken logo&#39;da,
ubuntu ise siyah ekranda çakılıp kalıyor donanımsal bir problemin olması muhtemel.Bu durumun çözümünü buldugumda burada paylaşıcam.
Harici diskten başlattığımda açılıp kendi diskinden açılmamasının nedenini anlyabilirsem durum çözülmüş olur sanırım.</p>

<p>Bu yazımın altında devam ediyorum..İşletim sistemlerinin açlırken donmasının ve sadece güvenli modda açmasının sebebi
ekran kartı arızalı oldugundan dolayı imişş.Çünkü güvenli modda açabiliyorsa harddiskin sağlam olduğu ortada ve cd&#39;den kuruluma başlarkende aynı durumlarla
karşılaşınca ekran kartında problem olma olasılığı maximum dereceye ulaşmıştı.Basit bir denemeyle kendisini ele verdi zaten..</p>
" class="label label-default"><p>Endüstri labında clonezilla ile imajı alıp diğer bilgisayarlara sistemi kopyalıyordum.
Ancak iki tanesinde problemle karşılaştım.Şunu da belirtim sistemlerin hepsi aynı yani lenovanın
sıfır bilgisayarlar ancak bir tanesinde ekran bozuklugu var yani görüntü bios&#39;a girdiğimde de kötü ve sistemler açılırken
kilitleniyor.Bundaki durumu ekran kartı sıkıntılıdır şeklinde düşünmüştüm ama diğerindeki durum gerçekten ilginc
imajın bulundugu diskten başlattıgımda açılıyor ama kendi diskine kopyalamayı yaptıktan sonra windows açılırken logo&#39;da,
ubuntu ise siyah ekranda çakılıp kalıyor donanımsal bir problemin olması muhtemel.Bu durumun çözümünü buldugumda burada paylaşıcam.
Harici diskten başlattığımda açılıp kendi diskinden açılmamasının nedenini anlyabilirsem durum çözülmüş olur sanırım.</p>

<p>Bu yazımın altında devam ediyorum..İşletim sistemlerinin açlırken donmasının ve sadece güvenli modda açmasının sebebi
ekran kartı arızalı oldugundan dolayı imişş.Çünkü güvenli modda açabiliyorsa harddiskin sağlam olduğu ortada ve cd&#39;den kuruluma başlarkende aynı durumlarla
karşılaşınca ekran kartında problem olma olasılığı maximum dereceye ulaşmıştı.Basit bir denemeyle kendisini ele verdi zaten..</p>
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/	#include <stdio.h>
	#include <stdlib.h>
	#include <dirent.h>
	#include <string.h>
	#include <sys/stat.h>
	#define MAX_PATH_SIZE 1024
	void DirWalk(const char *path, void (*Proc) (const char *))
	{
		char fname[MAX_PATH_SIZE];
		struct dirent *de;
		struct stat status;
		DIR *dir;
		if ((dir = opendir(path)) == NULL) {
			perror("opendir");
			return;
		}
		while ((de = readdir(dir)) != NULL) {
			sprintf(fname, "%s/%s", path, de->d_name);
			Proc(fname);
			if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {
				if (stat(fname, &status) == -1) {
					perror("stat");
					break;
				}
				if (S_ISDIR(status.st_mode))
					DirWalk(fname, Proc);
			}	
		}
		closedir(dir);
	}
	void Disp(const char *name)
	{
		puts(name);
	}
	int main(int argc, char *argv[])
	{
		char fname[MAX_PATH_SIZE];
		char *plast;
		if (argc != 2) {
			printf("Usage: dirtree <path>\n");
			exit(1);
		}
		strcpy(fname, argv[1]);
		plast = strchr(fname, '\0') - 1;
		if (*plast == '/')
			*plast = '\0';
		DirWalk(fname, Disp);
	return 0; 
	}
`void DirWalk(const char *path, void (*Proc) (const char *))` ifadesinde *path ile /etc gibi bir string ve bir fonksiyon işaretçisi alırız.

`struct dirent *de;`dirent yapısında d_ino ve d_name yapıları bulunmaktadır.Buradan readdir fonksiyonunun struct döndüğünü görebiliriz.

`if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {`"." bulundugu dizin,".." üst dizini gösterdiğinden programın tekrardan bu dizinlere girmesini engelliyor.

strcmp fonksiyonunun harf harf karşılaştırma yapmakda yukarıdaki ifademizde dosya adı "." veya ".." olduğunda strcmp sıfır değeri dönecektir.

`if (stat(fname, &status) == -1) {` stat fonksiyonu başarısızlık durumunda -1 döner.Ve status dosya bilgilerini tutar(örnek:dosya erişimindeki izin bilgileri gibi).
Ancak burada kullanılmasının amacı her gelişinde değişen fname ile birlikte status durumunuda set etmek ve S_ISDIR fonksiyonunda kullanmak.

`perror("stat");` perror fonksiyonunu çıktısı "stat:burası errno değişkenine karşılık gelen mesaj metni" şeklinde olur.
errno değişkenine mesaj metni stat fonksiyonu tarafından yukarıdaki kontrolde set edilmiştir.

`if (S_ISDIR(status.st_mode))` Status değişkeninde dosya bilgileri tutuluyordu burada dosyanın dizin mi ? kontrolünü yapar evetse özyineli yapıya dönüşür.

`DirWalk(fname, Proc);` proc fonksiyon göstericisine ana fonksiyonda Disp'i atamıştık zaten.

`plast = strchr(fname, '\0') - 1;` strchr belirtilen karakteri ilk bulduğunda belirtilen karekterin adresini dönmektedir.

`if (*plast == '/')` gelen path'in sonundaki "/" ifadesini kaldırıyoruz.

`DirWalk(fname, Disp);` path'i ve puts çıktısını üreten fonksiyonumuzu işaret ediyoruz." title="	#include <stdio.h>
	#include <stdlib.h>
	#include <dirent.h>
	#include <string.h>
	#include <sys/stat.h>
	#define MAX_PATH_SIZE 1024
	void DirWalk(const char *path, void (*Proc) (const char *))
	{
		char fname[MAX_PATH_SIZE];
		struct dirent *de;
		struct stat status;
		DIR *dir;
		if ((dir = opendir(path)) == NULL) {
			perror("opendir");
			return;
		}
		while ((de = readdir(dir)) != NULL) {
			sprintf(fname, "%s/%s", path, de->d_name);
			Proc(fname);
			if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {
				if (stat(fname, &status) == -1) {
					perror("stat");
					break;
				}
				if (S_ISDIR(status.st_mode))
					DirWalk(fname, Proc);
			}	
		}
		closedir(dir);
	}
	void Disp(const char *name)
	{
		puts(name);
	}
	int main(int argc, char *argv[])
	{
		char fname[MAX_PATH_SIZE];
		char *plast;
		if (argc != 2) {
			printf("Usage: dirtree <path>\n");
			exit(1);
		}
		strcpy(fname, argv[1]);
		plast = strchr(fname, '\0') - 1;
		if (*plast == '/')
			*plast = '\0';
		DirWalk(fname, Disp);
	return 0; 
	}
`void DirWalk(const char *path, void (*Proc) (const char *))` ifadesinde *path ile /etc gibi bir string ve bir fonksiyon işaretçisi alırız.

`struct dirent *de;`dirent yapısında d_ino ve d_name yapıları bulunmaktadır.Buradan readdir fonksiyonunun struct döndüğünü görebiliriz.

`if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {`"." bulundugu dizin,".." üst dizini gösterdiğinden programın tekrardan bu dizinlere girmesini engelliyor.

strcmp fonksiyonunun harf harf karşılaştırma yapmakda yukarıdaki ifademizde dosya adı "." veya ".." olduğunda strcmp sıfır değeri dönecektir.

`if (stat(fname, &status) == -1) {` stat fonksiyonu başarısızlık durumunda -1 döner.Ve status dosya bilgilerini tutar(örnek:dosya erişimindeki izin bilgileri gibi).
Ancak burada kullanılmasının amacı her gelişinde değişen fname ile birlikte status durumunuda set etmek ve S_ISDIR fonksiyonunda kullanmak.

`perror("stat");` perror fonksiyonunu çıktısı "stat:burası errno değişkenine karşılık gelen mesaj metni" şeklinde olur.
errno değişkenine mesaj metni stat fonksiyonu tarafından yukarıdaki kontrolde set edilmiştir.

`if (S_ISDIR(status.st_mode))` Status değişkeninde dosya bilgileri tutuluyordu burada dosyanın dizin mi ? kontrolünü yapar evetse özyineli yapıya dönüşür.

`DirWalk(fname, Proc);` proc fonksiyon göstericisine ana fonksiyonda Disp'i atamıştık zaten.

`plast = strchr(fname, '\0') - 1;` strchr belirtilen karakteri ilk bulduğunda belirtilen karekterin adresini dönmektedir.

`if (*plast == '/')` gelen path'in sonundaki "/" ifadesini kaldırıyoruz.

`DirWalk(fname, Disp);` path'i ve puts çıktısını üreten fonksiyonumuzu işaret ediyoruz." class="label label-default">	#include <stdio.h>
	#include <stdlib.h>
	#include <dirent.h>
	#include <string.h>
	#include <sys/stat.h>
	#define MAX_PATH_SIZE 1024
	void DirWalk(const char *path, void (*Proc) (const char *))
	{
		char fname[MAX_PATH_SIZE];
		struct dirent *de;
		struct stat status;
		DIR *dir;
		if ((dir = opendir(path)) == NULL) {
			perror("opendir");
			return;
		}
		while ((de = readdir(dir)) != NULL) {
			sprintf(fname, "%s/%s", path, de->d_name);
			Proc(fname);
			if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {
				if (stat(fname, &status) == -1) {
					perror("stat");
					break;
				}
				if (S_ISDIR(status.st_mode))
					DirWalk(fname, Proc);
			}	
		}
		closedir(dir);
	}
	void Disp(const char *name)
	{
		puts(name);
	}
	int main(int argc, char *argv[])
	{
		char fname[MAX_PATH_SIZE];
		char *plast;
		if (argc != 2) {
			printf("Usage: dirtree <path>\n");
			exit(1);
		}
		strcpy(fname, argv[1]);
		plast = strchr(fname, '\0') - 1;
		if (*plast == '/')
			*plast = '\0';
		DirWalk(fname, Disp);
	return 0; 
	}
`void DirWalk(const char *path, void (*Proc) (const char *))` ifadesinde *path ile /etc gibi bir string ve bir fonksiyon işaretçisi alırız.

`struct dirent *de;`dirent yapısında d_ino ve d_name yapıları bulunmaktadır.Buradan readdir fonksiyonunun struct döndüğünü görebiliriz.

`if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") != 0) {`"." bulundugu dizin,".." üst dizini gösterdiğinden programın tekrardan bu dizinlere girmesini engelliyor.

strcmp fonksiyonunun harf harf karşılaştırma yapmakda yukarıdaki ifademizde dosya adı "." veya ".." olduğunda strcmp sıfır değeri dönecektir.

`if (stat(fname, &status) == -1) {` stat fonksiyonu başarısızlık durumunda -1 döner.Ve status dosya bilgilerini tutar(örnek:dosya erişimindeki izin bilgileri gibi).
Ancak burada kullanılmasının amacı her gelişinde değişen fname ile birlikte status durumunuda set etmek ve S_ISDIR fonksiyonunda kullanmak.

`perror("stat");` perror fonksiyonunu çıktısı "stat:burası errno değişkenine karşılık gelen mesaj metni" şeklinde olur.
errno değişkenine mesaj metni stat fonksiyonu tarafından yukarıdaki kontrolde set edilmiştir.

`if (S_ISDIR(status.st_mode))` Status değişkeninde dosya bilgileri tutuluyordu burada dosyanın dizin mi ? kontrolünü yapar evetse özyineli yapıya dönüşür.

`DirWalk(fname, Proc);` proc fonksiyon göstericisine ana fonksiyonda Disp'i atamıştık zaten.

`plast = strchr(fname, '\0') - 1;` strchr belirtilen karakteri ilk bulduğunda belirtilen karekterin adresini dönmektedir.

`if (*plast == '/')` gelen path'in sonundaki "/" ifadesini kaldırıyoruz.

`DirWalk(fname, Disp);` path'i ve puts çıktısını üreten fonksiyonumuzu işaret ediyoruz.</a>
	  
  
	  
	    <li><a href="/tag/bash" title="bash" class="label label-default">bash</a>
	  
	    <li><a href="/tag/Bugün çok garip bir durumla karşılaştım aslında karşılaştığım durum basit ama karşılaşma zamanı garip oldu..

yaklaşık olarak 3 saat önce bir blog'ta adamın karşılaştığı ilginç bir olayı okuyordum yani adama göre beklenmeyen
bir durum olduğu için ilginçmiş dosya sistemini çok dikkatli kullanmasına rağmen nedini bilmediği bir şekilde terminale düşmüş

terminal diyorum terminal eminlatörü değil yani =) herneyse ondan sonra dosya sistemini düzenlemesi için fsck komutunun oldugunu görmüş.
Yani fsck dosya sistemindeki küçük hataları giderir gideremediği büyük hatalar içinde kullanıcıya uyarı veren bir programdır.
Bu şekilde oturumuna geri dönmüş.Beni ilgilendiren kısmı bu yazıyı okuduktan 15 dk sonra bilgisayarımın güncelleme yöneticisinin karşıma çıkıp
donmasıyla başladı.Bu durumda gayet sogukkanlı bir şekilde ana şartele basılı tutarak kapattım ancak açtığım zaman disk'i check ediyor fakat açılmıyordu
2. denememde bu sefer okuduğum şahsın düştüğü terminale bende düştüm ve dedim bu arkadaşı fsck kurtardıysa beni neden kurtarmasın ve tabiki bunları sogukkanlı
bir şekilde yapıyorum.Ve bende oturumuma dönmeyi başardım.

Burada dikkat etmemiz gereken nokta bilgisayarı düzgün kapatmadığımdır ve bu durumda superblocklara düzgün kapanmadıgına dair işaret biti yerleşmekte ve
check etme durumu bu şekilde başlamaktadır.Ext3 dosya sistemleri günlüklü yapıda olduklarından check ile düzgün yapısına dönüşür.Peki ya check etme esnasında fsck'nın yaptıgı
durumun aynısını gerçekleştirmedi mi ? 

işte böyle bir garip durumla karşılaştım eğer bunu okuyorsanız dikkat edin sizde terminale düşebilirsiniz o durumda
fsck kurtarıyor
" title="Bugün çok garip bir durumla karşılaştım aslında karşılaştığım durum basit ama karşılaşma zamanı garip oldu..

yaklaşık olarak 3 saat önce bir blog'ta adamın karşılaştığı ilginç bir olayı okuyordum yani adama göre beklenmeyen
bir durum olduğu için ilginçmiş dosya sistemini çok dikkatli kullanmasına rağmen nedini bilmediği bir şekilde terminale düşmüş

terminal diyorum terminal eminlatörü değil yani =) herneyse ondan sonra dosya sistemini düzenlemesi için fsck komutunun oldugunu görmüş.
Yani fsck dosya sistemindeki küçük hataları giderir gideremediği büyük hatalar içinde kullanıcıya uyarı veren bir programdır.
Bu şekilde oturumuna geri dönmüş.Beni ilgilendiren kısmı bu yazıyı okuduktan 15 dk sonra bilgisayarımın güncelleme yöneticisinin karşıma çıkıp
donmasıyla başladı.Bu durumda gayet sogukkanlı bir şekilde ana şartele basılı tutarak kapattım ancak açtığım zaman disk'i check ediyor fakat açılmıyordu
2. denememde bu sefer okuduğum şahsın düştüğü terminale bende düştüm ve dedim bu arkadaşı fsck kurtardıysa beni neden kurtarmasın ve tabiki bunları sogukkanlı
bir şekilde yapıyorum.Ve bende oturumuma dönmeyi başardım.

Burada dikkat etmemiz gereken nokta bilgisayarı düzgün kapatmadığımdır ve bu durumda superblocklara düzgün kapanmadıgına dair işaret biti yerleşmekte ve
check etme durumu bu şekilde başlamaktadır.Ext3 dosya sistemleri günlüklü yapıda olduklarından check ile düzgün yapısına dönüşür.Peki ya check etme esnasında fsck'nın yaptıgı
durumun aynısını gerçekleştirmedi mi ? 

işte böyle bir garip durumla karşılaştım eğer bunu okuyorsanız dikkat edin sizde terminale düşebilirsiniz o durumda
fsck kurtarıyor
" class="label label-default">Bugün çok garip bir durumla karşılaştım aslında karşılaştığım durum basit ama karşılaşma zamanı garip oldu..

yaklaşık olarak 3 saat önce bir blog'ta adamın karşılaştığı ilginç bir olayı okuyordum yani adama göre beklenmeyen
bir durum olduğu için ilginçmiş dosya sistemini çok dikkatli kullanmasına rağmen nedini bilmediği bir şekilde terminale düşmüş

terminal diyorum terminal eminlatörü değil yani =) herneyse ondan sonra dosya sistemini düzenlemesi için fsck komutunun oldugunu görmüş.
Yani fsck dosya sistemindeki küçük hataları giderir gideremediği büyük hatalar içinde kullanıcıya uyarı veren bir programdır.
Bu şekilde oturumuna geri dönmüş.Beni ilgilendiren kısmı bu yazıyı okuduktan 15 dk sonra bilgisayarımın güncelleme yöneticisinin karşıma çıkıp
donmasıyla başladı.Bu durumda gayet sogukkanlı bir şekilde ana şartele basılı tutarak kapattım ancak açtığım zaman disk'i check ediyor fakat açılmıyordu
2. denememde bu sefer okuduğum şahsın düştüğü terminale bende düştüm ve dedim bu arkadaşı fsck kurtardıysa beni neden kurtarmasın ve tabiki bunları sogukkanlı
bir şekilde yapıyorum.Ve bende oturumuma dönmeyi başardım.

Burada dikkat etmemiz gereken nokta bilgisayarı düzgün kapatmadığımdır ve bu durumda superblocklara düzgün kapanmadıgına dair işaret biti yerleşmekte ve
check etme durumu bu şekilde başlamaktadır.Ext3 dosya sistemleri günlüklü yapıda olduklarından check ile düzgün yapısına dönüşür.Peki ya check etme esnasında fsck'nın yaptıgı
durumun aynısını gerçekleştirmedi mi ? 

işte böyle bir garip durumla karşılaştım eğer bunu okuyorsanız dikkat edin sizde terminale düşebilirsiniz o durumda
fsck kurtarıyor
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/#### Subshell

Subshell xterm emilatöründeyken yeni bir bash prosesinin forklanmasıdır.yani:
	
	budizin=$( pwd ; echo "hımm" )
	echo $budizin

dediğimizde `$( pwd ; echo "hımm" )` ifadesinde bir çocuk prosesi üretilir ve komut burada yorumlanır.ancak

	budizin=$( pwd ; var="hımm" )
	echo $budizin

dediğimizde anaprosese döndüğünde `$budizin` ifadesini yazdırdığında `var="hıımm"` değişkenini göremez çünkü
subshell'de yaratılan değişkenler local olarak oluşturulmaktadır.
Bu durumun ne gibi kullanımı vardır ?
örnek : `echo "sistem adi : $( uname -n ) 'dir ."`  dediğimizde subshell'e girip sistem adını basıp çıkıcaktır.


export komutuyla anaprosesten subshell'e değişiken gönderebilriz.
	
	export var="merhaba"
	bash #subshell'e giriyoruz.
	echo $var 

yada

	var="merhaba"
	export var
	bash
	echo $var

dediğimizde subshell gönderdiğimiz var değişkenini görmektedir.Ancak
Subshell'deyken export yapamayız ana prosesteyken export yapabiliriz buda subshell'in variable listesine ekleme yapar.

Yada `var="merhaba" bash ` diyerek export etmeden direk değişkeni gönderebiliriz ancak bu durumda ana proses tarafından bu değişken tanımlı olmucaktır.

####Shell değişken değiştirme

Burada değişkenimizin karekterleri üzerinde oynamalar yapabilicez.Örnek :

	var=/foo/bar/baz

	echo "${ var##*/ }"

Dediğimizde değişkenimizin başından itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktısı >> baz

	echo "${var#*/}"

Bu durumda ise değişkenin başından itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktısı >> foo/bar/baz 

	echo "${var%/*}"

Burada ise değişkenin sonundan itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktı >> /foo/bar

	echo "${var%%/*}"

Dediğimizde değişkenimizin sonundan itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktı >> "boş"

Anlaşılacağı üzere taradıgı alan haricini döndürmektedir ve de `#` ile `%` karakterleri en az mesafeyi `##` ile `##` karakterleride en fazla mesafeyi ifade etmektedir.



#### Cut komutu

Cut komutu default olarak tab'a göre ayarlanmıştır. `cut  -f2` komutu'na gelen girdide tab karekteri varsa tab'a göre ayraçlık yapar ve ikinci kısmını geri döner.
Eğer tab karekteri yoksa metnin kendisini döndürür.

`cut -d ' : ' -f3 ` ifadesindeki `-d` paremetresi ayraç vereceğimizi bildirmektedir ve tırnaklar içinde verilen `:`  karakterine göre ayıracağını ve 3. parçasını döndürmektedir.
Bunu:
	cut -d ' ' -f2-4
olacak şekildede yazabiliriz.`-f2-4` ifadesi parçalardan 2 ve 4 dahil olmak üzere o aralığı döndürmektedir.

	line="a:b:c:d"
	karakter=$( echo $line | cut -d ':' -f3 )
	echo $karakter 
Dediğimizde `c` 'yi döndürecektir.

Bu şekilde girdiyi istediğimiz karaktere göre ayırabiliriz.Awk programıyla'da benzer işi yapabiliriz ve awk programı daha kapsamlı olmasına rağmen cut komutu ile neredeyse 
eşdeğer çalışmaktadır.Awk programının kullanımını daha sonradan bahsedicem ancak basit olarak 

	echo "a ? b ? c ? d:e " | awk -F ? ' { print $4 } '
çıktı -> d:e

Dediğimizde `-F` paremetresi alan ayıraçı anlamında yani default olarak değilde verdiğimiz `?` karekterine göre ayırmamızı sağlamaktadır.
`'{print $4}'` ifadesindeki `$4` parçalamadan sonraki 4. parçamızı ifade etmektedir.

Bu şekil cut ve awk programlarını kullanarak işlemimizi gerçekleştirebiliriz ancak bunun için shell'in kendi imkanlarını kullanmak daha mantıklı olacaktır.
Her seferinde cut ve awk'nın forklanması için ayrı bir sürede harcamamış olucaz.Bunu şu şekilde gösterebiliriz.

	#!/bin/bash

        ifs_save=$IFS
        IFS=:
        while read line ; do
                set $line
                echo "kabuk : $7"
        done < /etc/passwd

Burada doğrudan shell'in kendi imkanlarını kullandık ve passwd dosyasının kullanıcıların kullandıkları kabuk programları listelemiş olduk.


" title="#### Subshell

Subshell xterm emilatöründeyken yeni bir bash prosesinin forklanmasıdır.yani:
	
	budizin=$( pwd ; echo "hımm" )
	echo $budizin

dediğimizde `$( pwd ; echo "hımm" )` ifadesinde bir çocuk prosesi üretilir ve komut burada yorumlanır.ancak

	budizin=$( pwd ; var="hımm" )
	echo $budizin

dediğimizde anaprosese döndüğünde `$budizin` ifadesini yazdırdığında `var="hıımm"` değişkenini göremez çünkü
subshell'de yaratılan değişkenler local olarak oluşturulmaktadır.
Bu durumun ne gibi kullanımı vardır ?
örnek : `echo "sistem adi : $( uname -n ) 'dir ."`  dediğimizde subshell'e girip sistem adını basıp çıkıcaktır.


export komutuyla anaprosesten subshell'e değişiken gönderebilriz.
	
	export var="merhaba"
	bash #subshell'e giriyoruz.
	echo $var 

yada

	var="merhaba"
	export var
	bash
	echo $var

dediğimizde subshell gönderdiğimiz var değişkenini görmektedir.Ancak
Subshell'deyken export yapamayız ana prosesteyken export yapabiliriz buda subshell'in variable listesine ekleme yapar.

Yada `var="merhaba" bash ` diyerek export etmeden direk değişkeni gönderebiliriz ancak bu durumda ana proses tarafından bu değişken tanımlı olmucaktır.

####Shell değişken değiştirme

Burada değişkenimizin karekterleri üzerinde oynamalar yapabilicez.Örnek :

	var=/foo/bar/baz

	echo "${ var##*/ }"

Dediğimizde değişkenimizin başından itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktısı >> baz

	echo "${var#*/}"

Bu durumda ise değişkenin başından itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktısı >> foo/bar/baz 

	echo "${var%/*}"

Burada ise değişkenin sonundan itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktı >> /foo/bar

	echo "${var%%/*}"

Dediğimizde değişkenimizin sonundan itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktı >> "boş"

Anlaşılacağı üzere taradıgı alan haricini döndürmektedir ve de `#` ile `%` karakterleri en az mesafeyi `##` ile `##` karakterleride en fazla mesafeyi ifade etmektedir.



#### Cut komutu

Cut komutu default olarak tab'a göre ayarlanmıştır. `cut  -f2` komutu'na gelen girdide tab karekteri varsa tab'a göre ayraçlık yapar ve ikinci kısmını geri döner.
Eğer tab karekteri yoksa metnin kendisini döndürür.

`cut -d ' : ' -f3 ` ifadesindeki `-d` paremetresi ayraç vereceğimizi bildirmektedir ve tırnaklar içinde verilen `:`  karakterine göre ayıracağını ve 3. parçasını döndürmektedir.
Bunu:
	cut -d ' ' -f2-4
olacak şekildede yazabiliriz.`-f2-4` ifadesi parçalardan 2 ve 4 dahil olmak üzere o aralığı döndürmektedir.

	line="a:b:c:d"
	karakter=$( echo $line | cut -d ':' -f3 )
	echo $karakter 
Dediğimizde `c` 'yi döndürecektir.

Bu şekilde girdiyi istediğimiz karaktere göre ayırabiliriz.Awk programıyla'da benzer işi yapabiliriz ve awk programı daha kapsamlı olmasına rağmen cut komutu ile neredeyse 
eşdeğer çalışmaktadır.Awk programının kullanımını daha sonradan bahsedicem ancak basit olarak 

	echo "a ? b ? c ? d:e " | awk -F ? ' { print $4 } '
çıktı -> d:e

Dediğimizde `-F` paremetresi alan ayıraçı anlamında yani default olarak değilde verdiğimiz `?` karekterine göre ayırmamızı sağlamaktadır.
`'{print $4}'` ifadesindeki `$4` parçalamadan sonraki 4. parçamızı ifade etmektedir.

Bu şekil cut ve awk programlarını kullanarak işlemimizi gerçekleştirebiliriz ancak bunun için shell'in kendi imkanlarını kullanmak daha mantıklı olacaktır.
Her seferinde cut ve awk'nın forklanması için ayrı bir sürede harcamamış olucaz.Bunu şu şekilde gösterebiliriz.

	#!/bin/bash

        ifs_save=$IFS
        IFS=:
        while read line ; do
                set $line
                echo "kabuk : $7"
        done < /etc/passwd

Burada doğrudan shell'in kendi imkanlarını kullandık ve passwd dosyasının kullanıcıların kullandıkları kabuk programları listelemiş olduk.


" class="label label-default">#### Subshell

Subshell xterm emilatöründeyken yeni bir bash prosesinin forklanmasıdır.yani:
	
	budizin=$( pwd ; echo "hımm" )
	echo $budizin

dediğimizde `$( pwd ; echo "hımm" )` ifadesinde bir çocuk prosesi üretilir ve komut burada yorumlanır.ancak

	budizin=$( pwd ; var="hımm" )
	echo $budizin

dediğimizde anaprosese döndüğünde `$budizin` ifadesini yazdırdığında `var="hıımm"` değişkenini göremez çünkü
subshell'de yaratılan değişkenler local olarak oluşturulmaktadır.
Bu durumun ne gibi kullanımı vardır ?
örnek : `echo "sistem adi : $( uname -n ) 'dir ."`  dediğimizde subshell'e girip sistem adını basıp çıkıcaktır.


export komutuyla anaprosesten subshell'e değişiken gönderebilriz.
	
	export var="merhaba"
	bash #subshell'e giriyoruz.
	echo $var 

yada

	var="merhaba"
	export var
	bash
	echo $var

dediğimizde subshell gönderdiğimiz var değişkenini görmektedir.Ancak
Subshell'deyken export yapamayız ana prosesteyken export yapabiliriz buda subshell'in variable listesine ekleme yapar.

Yada `var="merhaba" bash ` diyerek export etmeden direk değişkeni gönderebiliriz ancak bu durumda ana proses tarafından bu değişken tanımlı olmucaktır.

####Shell değişken değiştirme

Burada değişkenimizin karekterleri üzerinde oynamalar yapabilicez.Örnek :

	var=/foo/bar/baz

	echo "${ var##*/ }"

Dediğimizde değişkenimizin başından itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktısı >> baz

	echo "${var#*/}"

Bu durumda ise değişkenin başından itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktısı >> foo/bar/baz 

	echo "${var%/*}"

Burada ise değişkenin sonundan itibaren tarayarak ilerle ve gidebileceğin en az mesafedeki `/` karakterinden sonrasını döndür.
çıktı >> /foo/bar

	echo "${var%%/*}"

Dediğimizde değişkenimizin sonundan itibaren tarayarak ilerle ve gidebileceğin en son yerdeki `/` karekterinden sonrasını döndür anlamındadır.
çıktı >> "boş"

Anlaşılacağı üzere taradıgı alan haricini döndürmektedir ve de `#` ile `%` karakterleri en az mesafeyi `##` ile `##` karakterleride en fazla mesafeyi ifade etmektedir.



#### Cut komutu

Cut komutu default olarak tab'a göre ayarlanmıştır. `cut  -f2` komutu'na gelen girdide tab karekteri varsa tab'a göre ayraçlık yapar ve ikinci kısmını geri döner.
Eğer tab karekteri yoksa metnin kendisini döndürür.

`cut -d ' : ' -f3 ` ifadesindeki `-d` paremetresi ayraç vereceğimizi bildirmektedir ve tırnaklar içinde verilen `:`  karakterine göre ayıracağını ve 3. parçasını döndürmektedir.
Bunu:
	cut -d ' ' -f2-4
olacak şekildede yazabiliriz.`-f2-4` ifadesi parçalardan 2 ve 4 dahil olmak üzere o aralığı döndürmektedir.

	line="a:b:c:d"
	karakter=$( echo $line | cut -d ':' -f3 )
	echo $karakter 
Dediğimizde `c` 'yi döndürecektir.

Bu şekilde girdiyi istediğimiz karaktere göre ayırabiliriz.Awk programıyla'da benzer işi yapabiliriz ve awk programı daha kapsamlı olmasına rağmen cut komutu ile neredeyse 
eşdeğer çalışmaktadır.Awk programının kullanımını daha sonradan bahsedicem ancak basit olarak 

	echo "a ? b ? c ? d:e " | awk -F ? ' { print $4 } '
çıktı -> d:e

Dediğimizde `-F` paremetresi alan ayıraçı anlamında yani default olarak değilde verdiğimiz `?` karekterine göre ayırmamızı sağlamaktadır.
`'{print $4}'` ifadesindeki `$4` parçalamadan sonraki 4. parçamızı ifade etmektedir.

Bu şekil cut ve awk programlarını kullanarak işlemimizi gerçekleştirebiliriz ancak bunun için shell'in kendi imkanlarını kullanmak daha mantıklı olacaktır.
Her seferinde cut ve awk'nın forklanması için ayrı bir sürede harcamamış olucaz.Bunu şu şekilde gösterebiliriz.

	#!/bin/bash

        ifs_save=$IFS
        IFS=:
        while read line ; do
                set $line
                echo "kabuk : $7"
        done < /etc/passwd

Burada doğrudan shell'in kendi imkanlarını kullandık ve passwd dosyasının kullanıcıların kullandıkları kabuk programları listelemiş olduk.


</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/Temanın admin panelinden oluşturulan tüm sayfalar tema klasöründeki page.php şablonundan türetilmektedir.
Eğer siz sadece tek bir sayfa için özellikler eklemek istiyorsanız mesela forum sayfası dışında tüm sayfalarda comment bloglarını kapatmak
istiyor iseniz `comments_template()` fonksiyonunu forum sayfası id'si için kullanabilirsiniz yada katı bağlantı kullanıp `$page_id` değişkeni
yerine sayfanın isminide page.php içinde if koşulu altına alıp sadece bu id'ye veya isime sahip sayfalara yorum bloglarını açabilirsiniz.

Eğer sayfa şablonlarında yapacağınız değişiklik bu denli küçük çapta değil ise yani diyelim ki footer'ın hemen üstüne javascript ile akan
bir duyuru koymak istiyorsanız.Örneğin duyuru.php sayfası oluşturdunuz ancak bunda sadece duyuru kısmı ( yani banner vs. kısımları yok ) var ve js kodunu duyuru.js 'den ve css'inide
duyuru.css 'den aldıgınız varsayalım bu durumda page.php içinde `include("duyuru.php")` çağrısı duyuru.js ve duyuru.css dosyalarını görmeyecektir.
Bunları duyuru.php içinde değilde temanın içinde bulunan `header.php` tanıtmalıyız.

Not: include fonksiyonu yerine require fonksiyonuda kullanılabilir. 
" title="Temanın admin panelinden oluşturulan tüm sayfalar tema klasöründeki page.php şablonundan türetilmektedir.
Eğer siz sadece tek bir sayfa için özellikler eklemek istiyorsanız mesela forum sayfası dışında tüm sayfalarda comment bloglarını kapatmak
istiyor iseniz `comments_template()` fonksiyonunu forum sayfası id'si için kullanabilirsiniz yada katı bağlantı kullanıp `$page_id` değişkeni
yerine sayfanın isminide page.php içinde if koşulu altına alıp sadece bu id'ye veya isime sahip sayfalara yorum bloglarını açabilirsiniz.

Eğer sayfa şablonlarında yapacağınız değişiklik bu denli küçük çapta değil ise yani diyelim ki footer'ın hemen üstüne javascript ile akan
bir duyuru koymak istiyorsanız.Örneğin duyuru.php sayfası oluşturdunuz ancak bunda sadece duyuru kısmı ( yani banner vs. kısımları yok ) var ve js kodunu duyuru.js 'den ve css'inide
duyuru.css 'den aldıgınız varsayalım bu durumda page.php içinde `include("duyuru.php")` çağrısı duyuru.js ve duyuru.css dosyalarını görmeyecektir.
Bunları duyuru.php içinde değilde temanın içinde bulunan `header.php` tanıtmalıyız.

Not: include fonksiyonu yerine require fonksiyonuda kullanılabilir. 
" class="label label-default">Temanın admin panelinden oluşturulan tüm sayfalar tema klasöründeki page.php şablonundan türetilmektedir.
Eğer siz sadece tek bir sayfa için özellikler eklemek istiyorsanız mesela forum sayfası dışında tüm sayfalarda comment bloglarını kapatmak
istiyor iseniz `comments_template()` fonksiyonunu forum sayfası id'si için kullanabilirsiniz yada katı bağlantı kullanıp `$page_id` değişkeni
yerine sayfanın isminide page.php içinde if koşulu altına alıp sadece bu id'ye veya isime sahip sayfalara yorum bloglarını açabilirsiniz.

Eğer sayfa şablonlarında yapacağınız değişiklik bu denli küçük çapta değil ise yani diyelim ki footer'ın hemen üstüne javascript ile akan
bir duyuru koymak istiyorsanız.Örneğin duyuru.php sayfası oluşturdunuz ancak bunda sadece duyuru kısmı ( yani banner vs. kısımları yok ) var ve js kodunu duyuru.js 'den ve css'inide
duyuru.css 'den aldıgınız varsayalım bu durumda page.php içinde `include("duyuru.php")` çağrısı duyuru.js ve duyuru.css dosyalarını görmeyecektir.
Bunları duyuru.php içinde değilde temanın içinde bulunan `header.php` tanıtmalıyız.

Not: include fonksiyonu yerine require fonksiyonuda kullanılabilir. 
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/Rails'in default ayarları sayesinde xml bir dosyayı düzenlemek ve çalıştırmak için fazla zaman harcamayız.
Railsde modeller, controller, view , images, style sheets, Javascript ve ayar dosyaları olmak üzere herşeyin yeri bellidir.

Rails MVC mimarisi ruby tarafından derlerdiğin için esnek ve hızlıdır.Genel olarak mimariden bahsedecek olursak

- Model : Database'e yazılacak olan veriyi belli kurallara tabi tutulmasıdır örnek olarak doldurulması gereken alanlardan istediğimizi zorunlu kılabilmemize olanak sağlamaktadır.

- Controller : Aldığı komutu çalıştırır ve dönüş değerini view'e geçer. Controller de bulunan methodlara gelen get , post gibi istekleri yönlendirmeden sorumludur.

- View : Verinin gösterilmesinden sorumludur. View complex mantık işlemlerinin içermemelidir. View contoller actionlarından gelen verilerin gösterilmesiden sorumludur.Controller ve View yapısı birbirine bağlı yapılardır.

rails mimarisinde veritabanındaki tabloların alanları sınıfların özelliğiymiş gibi atanıp active record sayesinde de veri üzerinde arama kaydetme gibi methodları kullanabiliriz.

kurulumu
	
    gem install rails

güncelleme
	
	gem update rails

veritabanı olarak mysql haricindeki veritabanı yöneticelerinde veritabanı sürücülerinin kurulması gerekmektedir.

Bütün kurulumlarmız tamamlandı ise eksik bileşenimizin olup olmadıgını `bundle install` komutu ile kontrol edebiliriz.Eğer mysql veritabanı kullanacak
iseniz sqlite3 eksikliğini göz ardı edebilirsiniz.

	rails new my-blog

diyerek blog uygulamamızı yarattıgımız zaman `config/database.yml` dosyamız default olarak sqlite3 'bağlı olarak gelecektir.

	rails new my-blog -d mysql

dediğimizde ise `-d` parametresinden sonra kullanacağımız veritabanımızı ismini girebiliriz.

	cd my-blog

uygulamamızın içinde `config/database.yml` dosyamızı düzenledikten sonra `rails server` diyerek rails ile gelen webrick'i başlatabiliriz bunun için projemizi oluşturduğumuz yerin önemi yoktur.
ve default olarak localhost'un 3000 portunda çalışmaktadır.Eğer istersen `-p` parametresi ile `rails server -p 27000` gibi istediğimiz ancak kullanılmayan portlar üzerinde çalıştırabiliriz.
tarayıcımızda `localhost:3000` adresine giderek çalıştıgından emin olabiliriz.



 
" title="Rails'in default ayarları sayesinde xml bir dosyayı düzenlemek ve çalıştırmak için fazla zaman harcamayız.
Railsde modeller, controller, view , images, style sheets, Javascript ve ayar dosyaları olmak üzere herşeyin yeri bellidir.

Rails MVC mimarisi ruby tarafından derlerdiğin için esnek ve hızlıdır.Genel olarak mimariden bahsedecek olursak

- Model : Database'e yazılacak olan veriyi belli kurallara tabi tutulmasıdır örnek olarak doldurulması gereken alanlardan istediğimizi zorunlu kılabilmemize olanak sağlamaktadır.

- Controller : Aldığı komutu çalıştırır ve dönüş değerini view'e geçer. Controller de bulunan methodlara gelen get , post gibi istekleri yönlendirmeden sorumludur.

- View : Verinin gösterilmesinden sorumludur. View complex mantık işlemlerinin içermemelidir. View contoller actionlarından gelen verilerin gösterilmesiden sorumludur.Controller ve View yapısı birbirine bağlı yapılardır.

rails mimarisinde veritabanındaki tabloların alanları sınıfların özelliğiymiş gibi atanıp active record sayesinde de veri üzerinde arama kaydetme gibi methodları kullanabiliriz.

kurulumu
	
    gem install rails

güncelleme
	
	gem update rails

veritabanı olarak mysql haricindeki veritabanı yöneticelerinde veritabanı sürücülerinin kurulması gerekmektedir.

Bütün kurulumlarmız tamamlandı ise eksik bileşenimizin olup olmadıgını `bundle install` komutu ile kontrol edebiliriz.Eğer mysql veritabanı kullanacak
iseniz sqlite3 eksikliğini göz ardı edebilirsiniz.

	rails new my-blog

diyerek blog uygulamamızı yarattıgımız zaman `config/database.yml` dosyamız default olarak sqlite3 'bağlı olarak gelecektir.

	rails new my-blog -d mysql

dediğimizde ise `-d` parametresinden sonra kullanacağımız veritabanımızı ismini girebiliriz.

	cd my-blog

uygulamamızın içinde `config/database.yml` dosyamızı düzenledikten sonra `rails server` diyerek rails ile gelen webrick'i başlatabiliriz bunun için projemizi oluşturduğumuz yerin önemi yoktur.
ve default olarak localhost'un 3000 portunda çalışmaktadır.Eğer istersen `-p` parametresi ile `rails server -p 27000` gibi istediğimiz ancak kullanılmayan portlar üzerinde çalıştırabiliriz.
tarayıcımızda `localhost:3000` adresine giderek çalıştıgından emin olabiliriz.



 
" class="label label-default">Rails'in default ayarları sayesinde xml bir dosyayı düzenlemek ve çalıştırmak için fazla zaman harcamayız.
Railsde modeller, controller, view , images, style sheets, Javascript ve ayar dosyaları olmak üzere herşeyin yeri bellidir.

Rails MVC mimarisi ruby tarafından derlerdiğin için esnek ve hızlıdır.Genel olarak mimariden bahsedecek olursak

- Model : Database'e yazılacak olan veriyi belli kurallara tabi tutulmasıdır örnek olarak doldurulması gereken alanlardan istediğimizi zorunlu kılabilmemize olanak sağlamaktadır.

- Controller : Aldığı komutu çalıştırır ve dönüş değerini view'e geçer. Controller de bulunan methodlara gelen get , post gibi istekleri yönlendirmeden sorumludur.

- View : Verinin gösterilmesinden sorumludur. View complex mantık işlemlerinin içermemelidir. View contoller actionlarından gelen verilerin gösterilmesiden sorumludur.Controller ve View yapısı birbirine bağlı yapılardır.

rails mimarisinde veritabanındaki tabloların alanları sınıfların özelliğiymiş gibi atanıp active record sayesinde de veri üzerinde arama kaydetme gibi methodları kullanabiliriz.

kurulumu
	
    gem install rails

güncelleme
	
	gem update rails

veritabanı olarak mysql haricindeki veritabanı yöneticelerinde veritabanı sürücülerinin kurulması gerekmektedir.

Bütün kurulumlarmız tamamlandı ise eksik bileşenimizin olup olmadıgını `bundle install` komutu ile kontrol edebiliriz.Eğer mysql veritabanı kullanacak
iseniz sqlite3 eksikliğini göz ardı edebilirsiniz.

	rails new my-blog

diyerek blog uygulamamızı yarattıgımız zaman `config/database.yml` dosyamız default olarak sqlite3 'bağlı olarak gelecektir.

	rails new my-blog -d mysql

dediğimizde ise `-d` parametresinden sonra kullanacağımız veritabanımızı ismini girebiliriz.

	cd my-blog

uygulamamızın içinde `config/database.yml` dosyamızı düzenledikten sonra `rails server` diyerek rails ile gelen webrick'i başlatabiliriz bunun için projemizi oluşturduğumuz yerin önemi yoktur.
ve default olarak localhost'un 3000 portunda çalışmaktadır.Eğer istersen `-p` parametresi ile `rails server -p 27000` gibi istediğimiz ancak kullanılmayan portlar üzerinde çalıştırabiliriz.
tarayıcımızda `localhost:3000` adresine giderek çalıştıgından emin olabiliriz.



 
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/Bu paket birçok eklenti tarafından kullanıldıgını belirtmek istiyorum. Kurulumun nasıl yapılacagını paket içindeki `Readme` dosyasında da 
görebilirsiniz.

Öncelikle jquery_ui paketinin kütüphanesini http://code.google.com/p/jquery-ui/downloads/list?q=1.6 adresten sürümünüz hangisiyse indirin
ben 1.6 kurulumunu anlatacağım.

İndirme işleminden sonra jquery_ui modules dosyalarının arasına çıkarın ve sites/all altında modules isimli klasör oluşturup bir kopyasınıda oraya koyun
kurulum esnasında buraya yönlendiriliyor. Siz o yüzden bir kopyasını koyun çünkü diğer türlü modul olarak görünmüyor.

jquery.ui kütüphanesinide yukarıda verdiğim adresten indirdikten sonra sites/all altında libraries klasörü oluşturup içine adı jquery.ui olacak şekilde
çıkartın bu aşamadan sonra eklentiler bölümünde kullanılabilir hale gelecektir.
" title="Bu paket birçok eklenti tarafından kullanıldıgını belirtmek istiyorum. Kurulumun nasıl yapılacagını paket içindeki `Readme` dosyasında da 
görebilirsiniz.

Öncelikle jquery_ui paketinin kütüphanesini http://code.google.com/p/jquery-ui/downloads/list?q=1.6 adresten sürümünüz hangisiyse indirin
ben 1.6 kurulumunu anlatacağım.

İndirme işleminden sonra jquery_ui modules dosyalarının arasına çıkarın ve sites/all altında modules isimli klasör oluşturup bir kopyasınıda oraya koyun
kurulum esnasında buraya yönlendiriliyor. Siz o yüzden bir kopyasını koyun çünkü diğer türlü modul olarak görünmüyor.

jquery.ui kütüphanesinide yukarıda verdiğim adresten indirdikten sonra sites/all altında libraries klasörü oluşturup içine adı jquery.ui olacak şekilde
çıkartın bu aşamadan sonra eklentiler bölümünde kullanılabilir hale gelecektir.
" class="label label-default">Bu paket birçok eklenti tarafından kullanıldıgını belirtmek istiyorum. Kurulumun nasıl yapılacagını paket içindeki `Readme` dosyasında da 
görebilirsiniz.

Öncelikle jquery_ui paketinin kütüphanesini http://code.google.com/p/jquery-ui/downloads/list?q=1.6 adresten sürümünüz hangisiyse indirin
ben 1.6 kurulumunu anlatacağım.

İndirme işleminden sonra jquery_ui modules dosyalarının arasına çıkarın ve sites/all altında modules isimli klasör oluşturup bir kopyasınıda oraya koyun
kurulum esnasında buraya yönlendiriliyor. Siz o yüzden bir kopyasını koyun çünkü diğer türlü modul olarak görünmüyor.

jquery.ui kütüphanesinide yukarıda verdiğim adresten indirdikten sonra sites/all altında libraries klasörü oluşturup içine adı jquery.ui olacak şekilde
çıkartın bu aşamadan sonra eklentiler bölümünde kullanılabilir hale gelecektir.
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/# Git Kullanımı

İlk olarak [SourceTree](http://www.sourcetreeapp.com/download/) 'den github ile bağlantı kuracağımız tool 'u indiriyoruz.

Kurulum Aşamaları;

- İlk gelen ekrandaki bilgiler commit aşamasında kullanılacak

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/1.png)

- İkinci ekranda bitbucket bilgilerimizi giriyoruz.

![İkinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/2.png)

- Bu aşamada istersek localde mevcut git depolarını keşfetmesini sağlayabiliriz.

![Üçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/3.png)

- Bu aşamada ister sol üst köşedeki button 'dan repo 'yu kendimiz manuel olarak ekleyebiliriz. Yada bir sonraki adımdaki işlemi uygulayabiliriz. Burda manuel olarak eklerken kullanacağımız url bir sonraki adımda gösterildi.

![Dördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/4.png)

- Bitbucket üzerindeki mevcut repoda clone kısmında terminal üzerinden manuel olarak clone etmemizi sağlayan komutu uygulayabiliriz. Yukarıdaki aşamada repo eklerken kullanacağımız url de burdaki url dir. Yada ekteki görselde belirtilen `Clone in SourceTree` tıklayarak direk SourceTree 'den clone yaptırabiliriz.

![Beşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/5.png)

![Altıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/6.png)

![Yedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/7.png)

- Bitbucket parolamızı giriyoruz.

![Sekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/8.png)

- Clone diyerek projeyi locale alıyoruz.

![Dokuzuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/9.png)

- Mevcut repolar ana menüde görünür halde, işlem yapmak istediğimiz repoyu seçiyoruz.

![Onuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/10.png)

- Repoda mevcut brach 'lar görünmekte master brach 'ı default olarak gelmekte. Bu brach 'a tıkladığımız zaman son zamanda yapılan commitler ve commitler de yapılan değişikliklere ulaşabiliyoruz.

![Onbirinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/11.png)

![Onikinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/12.png)

![Onüçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/13.png)

- Projemiz üzerinde değişiklik yaptığımız zaman eğer master branch üzerindeysek `Uncommitted changes` olarak görünmektedir

![Ondördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/14.png)

- Bu commitlenmemiş değişikliği `commit` edebilmek için öncelikle `add` işlemini yapmalıyız. Bunun için commitlenmemiş satırı seçip üst menüden add iconuna tıklayarak commit edilmek için hazır hale getirmeliyiz.

- Burda asıl dikkat edilmesi gereken nokta `Uncommited changes` satırı seçildiği zaman şuanda working directory içinde yapılan tüm dosyalardaki değişiklikleri `files in working tree` kısmından görebiliriz. Yani burdaki kısım projemizdeki değişiklik yapılmış dosyaları göstermektedir. Biz burdan hangi dosyaları commitlemek istiyorsak önce onu seçip üst menüden `add` diyerek `files staged in index` kısmına geçirmeliyiz. Yani üst menüden `commit` butonuna tıkladığımız zaman bu kısımdaki dosyalar commitlenicektir. O zaman commitleme esnasında yaptığımız değişikliklerin hepsini birden commitlemek yerine yapılan işlemleri parçalara ayırıp ilişkili dosyaları commitlemek daha temiz bir commit yapısı sunar.

- Yani eğer değişiklik yaptığımız tüm dosyaları commitlemek istiyorsak `files in working tree` kısmındaki tüm dosyaları seçip `add` dememiz gerekmektedir. Bundan sonra commit yapabiliriz.


![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/22.png)

![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/23.png)

- `files staged in index` kısmındaki dosyaları commitlemek için üst menüden `commit` butonuna tıklamalıyız.

![Onaltıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/16.png)

- Commit mesajını girmeliyiz. Bu kısmı boş bırakmamalıyız.

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/17.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/18.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/19.png)

- Commit işlemi aslında hangi dosyalarda ne değişiklik yapılmış bu bilgiyi entegre etme aşamasıdır. Değişikliklerimizi tam olarak göndermek için üst menüden `push` butonuna tıklamalıyız.

![Onsekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/20.png)


- Repo üzerinde yapılan değişiklikleri çekmek için üst menüden `pull` butonuna tıklıyoruz.

işlem tamamdır." title="# Git Kullanımı

İlk olarak [SourceTree](http://www.sourcetreeapp.com/download/) 'den github ile bağlantı kuracağımız tool 'u indiriyoruz.

Kurulum Aşamaları;

- İlk gelen ekrandaki bilgiler commit aşamasında kullanılacak

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/1.png)

- İkinci ekranda bitbucket bilgilerimizi giriyoruz.

![İkinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/2.png)

- Bu aşamada istersek localde mevcut git depolarını keşfetmesini sağlayabiliriz.

![Üçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/3.png)

- Bu aşamada ister sol üst köşedeki button 'dan repo 'yu kendimiz manuel olarak ekleyebiliriz. Yada bir sonraki adımdaki işlemi uygulayabiliriz. Burda manuel olarak eklerken kullanacağımız url bir sonraki adımda gösterildi.

![Dördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/4.png)

- Bitbucket üzerindeki mevcut repoda clone kısmında terminal üzerinden manuel olarak clone etmemizi sağlayan komutu uygulayabiliriz. Yukarıdaki aşamada repo eklerken kullanacağımız url de burdaki url dir. Yada ekteki görselde belirtilen `Clone in SourceTree` tıklayarak direk SourceTree 'den clone yaptırabiliriz.

![Beşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/5.png)

![Altıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/6.png)

![Yedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/7.png)

- Bitbucket parolamızı giriyoruz.

![Sekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/8.png)

- Clone diyerek projeyi locale alıyoruz.

![Dokuzuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/9.png)

- Mevcut repolar ana menüde görünür halde, işlem yapmak istediğimiz repoyu seçiyoruz.

![Onuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/10.png)

- Repoda mevcut brach 'lar görünmekte master brach 'ı default olarak gelmekte. Bu brach 'a tıkladığımız zaman son zamanda yapılan commitler ve commitler de yapılan değişikliklere ulaşabiliyoruz.

![Onbirinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/11.png)

![Onikinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/12.png)

![Onüçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/13.png)

- Projemiz üzerinde değişiklik yaptığımız zaman eğer master branch üzerindeysek `Uncommitted changes` olarak görünmektedir

![Ondördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/14.png)

- Bu commitlenmemiş değişikliği `commit` edebilmek için öncelikle `add` işlemini yapmalıyız. Bunun için commitlenmemiş satırı seçip üst menüden add iconuna tıklayarak commit edilmek için hazır hale getirmeliyiz.

- Burda asıl dikkat edilmesi gereken nokta `Uncommited changes` satırı seçildiği zaman şuanda working directory içinde yapılan tüm dosyalardaki değişiklikleri `files in working tree` kısmından görebiliriz. Yani burdaki kısım projemizdeki değişiklik yapılmış dosyaları göstermektedir. Biz burdan hangi dosyaları commitlemek istiyorsak önce onu seçip üst menüden `add` diyerek `files staged in index` kısmına geçirmeliyiz. Yani üst menüden `commit` butonuna tıkladığımız zaman bu kısımdaki dosyalar commitlenicektir. O zaman commitleme esnasında yaptığımız değişikliklerin hepsini birden commitlemek yerine yapılan işlemleri parçalara ayırıp ilişkili dosyaları commitlemek daha temiz bir commit yapısı sunar.

- Yani eğer değişiklik yaptığımız tüm dosyaları commitlemek istiyorsak `files in working tree` kısmındaki tüm dosyaları seçip `add` dememiz gerekmektedir. Bundan sonra commit yapabiliriz.


![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/22.png)

![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/23.png)

- `files staged in index` kısmındaki dosyaları commitlemek için üst menüden `commit` butonuna tıklamalıyız.

![Onaltıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/16.png)

- Commit mesajını girmeliyiz. Bu kısmı boş bırakmamalıyız.

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/17.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/18.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/19.png)

- Commit işlemi aslında hangi dosyalarda ne değişiklik yapılmış bu bilgiyi entegre etme aşamasıdır. Değişikliklerimizi tam olarak göndermek için üst menüden `push` butonuna tıklamalıyız.

![Onsekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/20.png)


- Repo üzerinde yapılan değişiklikleri çekmek için üst menüden `pull` butonuna tıklıyoruz.

işlem tamamdır." class="label label-default"># Git Kullanımı

İlk olarak [SourceTree](http://www.sourcetreeapp.com/download/) 'den github ile bağlantı kuracağımız tool 'u indiriyoruz.

Kurulum Aşamaları;

- İlk gelen ekrandaki bilgiler commit aşamasında kullanılacak

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/1.png)

- İkinci ekranda bitbucket bilgilerimizi giriyoruz.

![İkinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/2.png)

- Bu aşamada istersek localde mevcut git depolarını keşfetmesini sağlayabiliriz.

![Üçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/3.png)

- Bu aşamada ister sol üst köşedeki button 'dan repo 'yu kendimiz manuel olarak ekleyebiliriz. Yada bir sonraki adımdaki işlemi uygulayabiliriz. Burda manuel olarak eklerken kullanacağımız url bir sonraki adımda gösterildi.

![Dördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/4.png)

- Bitbucket üzerindeki mevcut repoda clone kısmında terminal üzerinden manuel olarak clone etmemizi sağlayan komutu uygulayabiliriz. Yukarıdaki aşamada repo eklerken kullanacağımız url de burdaki url dir. Yada ekteki görselde belirtilen `Clone in SourceTree` tıklayarak direk SourceTree 'den clone yaptırabiliriz.

![Beşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/5.png)

![Altıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/6.png)

![Yedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/7.png)

- Bitbucket parolamızı giriyoruz.

![Sekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/8.png)

- Clone diyerek projeyi locale alıyoruz.

![Dokuzuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/9.png)

- Mevcut repolar ana menüde görünür halde, işlem yapmak istediğimiz repoyu seçiyoruz.

![Onuncu Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/10.png)

- Repoda mevcut brach 'lar görünmekte master brach 'ı default olarak gelmekte. Bu brach 'a tıkladığımız zaman son zamanda yapılan commitler ve commitler de yapılan değişikliklere ulaşabiliyoruz.

![Onbirinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/11.png)

![Onikinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/12.png)

![Onüçüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/13.png)

- Projemiz üzerinde değişiklik yaptığımız zaman eğer master branch üzerindeysek `Uncommitted changes` olarak görünmektedir

![Ondördüncü Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/14.png)

- Bu commitlenmemiş değişikliği `commit` edebilmek için öncelikle `add` işlemini yapmalıyız. Bunun için commitlenmemiş satırı seçip üst menüden add iconuna tıklayarak commit edilmek için hazır hale getirmeliyiz.

- Burda asıl dikkat edilmesi gereken nokta `Uncommited changes` satırı seçildiği zaman şuanda working directory içinde yapılan tüm dosyalardaki değişiklikleri `files in working tree` kısmından görebiliriz. Yani burdaki kısım projemizdeki değişiklik yapılmış dosyaları göstermektedir. Biz burdan hangi dosyaları commitlemek istiyorsak önce onu seçip üst menüden `add` diyerek `files staged in index` kısmına geçirmeliyiz. Yani üst menüden `commit` butonuna tıkladığımız zaman bu kısımdaki dosyalar commitlenicektir. O zaman commitleme esnasında yaptığımız değişikliklerin hepsini birden commitlemek yerine yapılan işlemleri parçalara ayırıp ilişkili dosyaları commitlemek daha temiz bir commit yapısı sunar.

- Yani eğer değişiklik yaptığımız tüm dosyaları commitlemek istiyorsak `files in working tree` kısmındaki tüm dosyaları seçip `add` dememiz gerekmektedir. Bundan sonra commit yapabiliriz.


![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/22.png)

![Onbeşinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/23.png)

- `files staged in index` kısmındaki dosyaları commitlemek için üst menüden `commit` butonuna tıklamalıyız.

![Onaltıncı Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/16.png)

- Commit mesajını girmeliyiz. Bu kısmı boş bırakmamalıyız.

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/17.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/18.png)

![Onyedinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/19.png)

- Commit işlemi aslında hangi dosyalarda ne değişiklik yapılmış bu bilgiyi entegre etme aşamasıdır. Değişikliklerimizi tam olarak göndermek için üst menüden `push` butonuna tıklamalıyız.

![Onsekizinci Aşama](https://raw.github.com/semihozkoroglu/File/master/SourceTree/20.png)


- Repo üzerinde yapılan değişiklikleri çekmek için üst menüden `pull` butonuna tıklıyoruz.

işlem tamamdır.</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/Turkcell modem kullanıyorum ve ubuntu 11.10 üzerinde bu modemi çalıştıramadım, yaptığım araştırmalar neticesinde Huawei E177 modellerinin sanal cdrom özelliği açık gelmekte ve bu sebeble ubuntu üzerinde bunu bir modem olarak göremiyoruz, ve şimdi modemimizin sanal cdrom özelliğini kapatmak için windows üzerinde birkaç işlem yapıcaz.

Bunun için öncelikle Putty programını şu adresten [indirin](http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe)

Şimdi putty ile modemimize seri bir bağlantı yaparak ayarlarını değiştiricez

Modemimizin hangi usb com'una bağlı oldugunu bulmak için Device manager'dan modem kısmından Huawei özelliklerine bakarak portunu buluyoruz.

Putty'i çalıştırdıktan sonra karşımıza çıkan pencerede serial kısmını seçerek ve portunu ( yani modem hangi slot'a takılı ise ) yazarak open diyoruz

Tabi bu arada `unable to connect` hatası alırsanız, şuanda sizin bir yandan modem üzerinden internet bağlantısını kullanmanızdan kaynaklanacak, bunun için öncelikle modemin internet bağlantısını kesiniz

putty ile modemimize bağlantı kurduğumuzda karşımıza açılan terminalde sırası ile şu komutları kullanın

-	`ATX`

- `AT^U2DIAG=0`

sanal özelliğinin açmak için ise `AT^U2DIAG=1` diyebiliriz.

Bundan sonra ubuntu üzerinde `Edit connection` kısmından `Mobile Broadband` bölümünü seçin ve ordan da yeni bağlantı eklemek için `add` seçeneğini seçin

Karşılaştıgımız kurulum penceresinde `Create a connection for this mobile broadband device` kısmında Huawei modemi görüyor olucaksınız,
ödeme planı kısmında ise APN mgb olarak belirtikten sonra ( Tabi bu modeme göre değişebilir ) bağlantınızı kurabilirsiniz.
" title="Turkcell modem kullanıyorum ve ubuntu 11.10 üzerinde bu modemi çalıştıramadım, yaptığım araştırmalar neticesinde Huawei E177 modellerinin sanal cdrom özelliği açık gelmekte ve bu sebeble ubuntu üzerinde bunu bir modem olarak göremiyoruz, ve şimdi modemimizin sanal cdrom özelliğini kapatmak için windows üzerinde birkaç işlem yapıcaz.

Bunun için öncelikle Putty programını şu adresten [indirin](http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe)

Şimdi putty ile modemimize seri bir bağlantı yaparak ayarlarını değiştiricez

Modemimizin hangi usb com'una bağlı oldugunu bulmak için Device manager'dan modem kısmından Huawei özelliklerine bakarak portunu buluyoruz.

Putty'i çalıştırdıktan sonra karşımıza çıkan pencerede serial kısmını seçerek ve portunu ( yani modem hangi slot'a takılı ise ) yazarak open diyoruz

Tabi bu arada `unable to connect` hatası alırsanız, şuanda sizin bir yandan modem üzerinden internet bağlantısını kullanmanızdan kaynaklanacak, bunun için öncelikle modemin internet bağlantısını kesiniz

putty ile modemimize bağlantı kurduğumuzda karşımıza açılan terminalde sırası ile şu komutları kullanın

-	`ATX`

- `AT^U2DIAG=0`

sanal özelliğinin açmak için ise `AT^U2DIAG=1` diyebiliriz.

Bundan sonra ubuntu üzerinde `Edit connection` kısmından `Mobile Broadband` bölümünü seçin ve ordan da yeni bağlantı eklemek için `add` seçeneğini seçin

Karşılaştıgımız kurulum penceresinde `Create a connection for this mobile broadband device` kısmında Huawei modemi görüyor olucaksınız,
ödeme planı kısmında ise APN mgb olarak belirtikten sonra ( Tabi bu modeme göre değişebilir ) bağlantınızı kurabilirsiniz.
" class="label label-default">Turkcell modem kullanıyorum ve ubuntu 11.10 üzerinde bu modemi çalıştıramadım, yaptığım araştırmalar neticesinde Huawei E177 modellerinin sanal cdrom özelliği açık gelmekte ve bu sebeble ubuntu üzerinde bunu bir modem olarak göremiyoruz, ve şimdi modemimizin sanal cdrom özelliğini kapatmak için windows üzerinde birkaç işlem yapıcaz.

Bunun için öncelikle Putty programını şu adresten [indirin](http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe)

Şimdi putty ile modemimize seri bir bağlantı yaparak ayarlarını değiştiricez

Modemimizin hangi usb com'una bağlı oldugunu bulmak için Device manager'dan modem kısmından Huawei özelliklerine bakarak portunu buluyoruz.

Putty'i çalıştırdıktan sonra karşımıza çıkan pencerede serial kısmını seçerek ve portunu ( yani modem hangi slot'a takılı ise ) yazarak open diyoruz

Tabi bu arada `unable to connect` hatası alırsanız, şuanda sizin bir yandan modem üzerinden internet bağlantısını kullanmanızdan kaynaklanacak, bunun için öncelikle modemin internet bağlantısını kesiniz

putty ile modemimize bağlantı kurduğumuzda karşımıza açılan terminalde sırası ile şu komutları kullanın

-	`ATX`

- `AT^U2DIAG=0`

sanal özelliğinin açmak için ise `AT^U2DIAG=1` diyebiliriz.

Bundan sonra ubuntu üzerinde `Edit connection` kısmından `Mobile Broadband` bölümünü seçin ve ordan da yeni bağlantı eklemek için `add` seçeneğini seçin

Karşılaştıgımız kurulum penceresinde `Create a connection for this mobile broadband device` kısmında Huawei modemi görüyor olucaksınız,
ödeme planı kısmında ise APN mgb olarak belirtikten sonra ( Tabi bu modeme göre değişebilir ) bağlantınızı kurabilirsiniz.
</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/# Git Flow

- Bu dökümanın [Burdaki](https://gist.github.com/semihozkoroglu/5932541) dökümandan sonra yazıldığı unutulmamalı.

- Git flow mekanizmasını anlamak için [SourceTree](http://www.sourcetreeapp.com/download/) tool 'unda mevcut olan gitflow eklentisi kullanıldı.

- Bu dökümanı oluşturmak için [atlassian](http://www.atlassian.com/git/workflows#!workflow-gitflow) , [nvie](http://nvie.com/posts/a-successful-git-branching-model/) dökümanlarından yararlanıldı. Daha fazla bilgi için incelemenizi öneririm.

- ilk olarak mevcut depomuzu `Clone in SourceTree` butonuna tıklayarak clone ediyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/1.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/2.png)

- İkinci olarak SourceTree tool 'unda sağ üst tarafta bulunan gitflow eklentisini kullanarak repomuzu ilklendiriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/3.png)

- localde depoları takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/4.png)

- Şimdi `Git Flow` butonuna tıklayarak yeni bir feature oluşturuyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/5.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/6.png)

- localde takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/7.png)

- feature üzerinde değişiklik yapıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/8.png)

- Değişiklik `SourceTree` tool 'u tarafından algılandı.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/9.png)

- Commit edilecek dosyayı seçip `Add` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/10.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/11.png)

- `Commit` diyerek commitliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/12.png)

- `Git Flow` 'a tıklayarak mevcut feature 'ı kapatıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/13.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/14.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/15.png)

- Açtığımız feature branch 'ını finish yaptığımız zaman yaptığımız eklemeler develop dalına merge ediliyor. Bu durumda Feature branch 'ını kapattıktan sonra develop dalında push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/16.png)

- Bitbucket 'a değişikliklerimiz gitmiş durumda.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/17.png)

- Şimdi geliştirmemizi developta tamamladık ve yeni bir versiyon çıkma zamanı geldi. `Git Flow` butonundan `Start new a Release` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/18.png)

- Ve versiyon numaramızı giriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/19.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/20.png)

- Ve şimdi sadece bu release branch 'ını oluşturduktan sonra finish yaptığımız zaman develop dalındaki tüm çalışmalarımız master dalına merge olucaktır.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/21.png)

- Yeni versiyonumuz için minik bir açıklama ekliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/22.png)

- localden takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/23.png)

- Ancak şuanda develop brach 'ı sadece master 'a merge olmuş durumda bunu push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/24.png)

- Branch ve Tag 'lerimizin son durumu

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/25.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/26.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/27.png)

- Kısaca amacımızı özetlemek gerekirse ana geliştirmemizi Develop dalında yapıyoruz. Ve Release edip master dalına geçirdiğimiz zaman aslında projemizin tamamen stabil olduğunu varsayıp bir versiyon tag 'i ekliyoruz. Develop dalında geliştirme yaparken ise projeyi parçalara ayırıp (veya bug, cr maddelerinin gelme durumunda) Feature brach 'ında tamamlayıp testinide yaptıktan sonra develop dalına merge işlemini yapıyoruz. Ve develop dalında geliştirdiğimiz proje mevcut özellikleri ile stabil duruma vardığında Release işlemini yapıyoruz. Master dalındaki projede bug bulunduğu zaman Hotfix branch 'ı açıp gerekli düzenlemeleri yaptıktan sonra kapatıldığında direk master 'a merge olucaktır." title="# Git Flow

- Bu dökümanın [Burdaki](https://gist.github.com/semihozkoroglu/5932541) dökümandan sonra yazıldığı unutulmamalı.

- Git flow mekanizmasını anlamak için [SourceTree](http://www.sourcetreeapp.com/download/) tool 'unda mevcut olan gitflow eklentisi kullanıldı.

- Bu dökümanı oluşturmak için [atlassian](http://www.atlassian.com/git/workflows#!workflow-gitflow) , [nvie](http://nvie.com/posts/a-successful-git-branching-model/) dökümanlarından yararlanıldı. Daha fazla bilgi için incelemenizi öneririm.

- ilk olarak mevcut depomuzu `Clone in SourceTree` butonuna tıklayarak clone ediyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/1.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/2.png)

- İkinci olarak SourceTree tool 'unda sağ üst tarafta bulunan gitflow eklentisini kullanarak repomuzu ilklendiriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/3.png)

- localde depoları takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/4.png)

- Şimdi `Git Flow` butonuna tıklayarak yeni bir feature oluşturuyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/5.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/6.png)

- localde takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/7.png)

- feature üzerinde değişiklik yapıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/8.png)

- Değişiklik `SourceTree` tool 'u tarafından algılandı.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/9.png)

- Commit edilecek dosyayı seçip `Add` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/10.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/11.png)

- `Commit` diyerek commitliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/12.png)

- `Git Flow` 'a tıklayarak mevcut feature 'ı kapatıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/13.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/14.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/15.png)

- Açtığımız feature branch 'ını finish yaptığımız zaman yaptığımız eklemeler develop dalına merge ediliyor. Bu durumda Feature branch 'ını kapattıktan sonra develop dalında push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/16.png)

- Bitbucket 'a değişikliklerimiz gitmiş durumda.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/17.png)

- Şimdi geliştirmemizi developta tamamladık ve yeni bir versiyon çıkma zamanı geldi. `Git Flow` butonundan `Start new a Release` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/18.png)

- Ve versiyon numaramızı giriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/19.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/20.png)

- Ve şimdi sadece bu release branch 'ını oluşturduktan sonra finish yaptığımız zaman develop dalındaki tüm çalışmalarımız master dalına merge olucaktır.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/21.png)

- Yeni versiyonumuz için minik bir açıklama ekliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/22.png)

- localden takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/23.png)

- Ancak şuanda develop brach 'ı sadece master 'a merge olmuş durumda bunu push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/24.png)

- Branch ve Tag 'lerimizin son durumu

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/25.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/26.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/27.png)

- Kısaca amacımızı özetlemek gerekirse ana geliştirmemizi Develop dalında yapıyoruz. Ve Release edip master dalına geçirdiğimiz zaman aslında projemizin tamamen stabil olduğunu varsayıp bir versiyon tag 'i ekliyoruz. Develop dalında geliştirme yaparken ise projeyi parçalara ayırıp (veya bug, cr maddelerinin gelme durumunda) Feature brach 'ında tamamlayıp testinide yaptıktan sonra develop dalına merge işlemini yapıyoruz. Ve develop dalında geliştirdiğimiz proje mevcut özellikleri ile stabil duruma vardığında Release işlemini yapıyoruz. Master dalındaki projede bug bulunduğu zaman Hotfix branch 'ı açıp gerekli düzenlemeleri yaptıktan sonra kapatıldığında direk master 'a merge olucaktır." class="label label-default"># Git Flow

- Bu dökümanın [Burdaki](https://gist.github.com/semihozkoroglu/5932541) dökümandan sonra yazıldığı unutulmamalı.

- Git flow mekanizmasını anlamak için [SourceTree](http://www.sourcetreeapp.com/download/) tool 'unda mevcut olan gitflow eklentisi kullanıldı.

- Bu dökümanı oluşturmak için [atlassian](http://www.atlassian.com/git/workflows#!workflow-gitflow) , [nvie](http://nvie.com/posts/a-successful-git-branching-model/) dökümanlarından yararlanıldı. Daha fazla bilgi için incelemenizi öneririm.

- ilk olarak mevcut depomuzu `Clone in SourceTree` butonuna tıklayarak clone ediyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/1.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/2.png)

- İkinci olarak SourceTree tool 'unda sağ üst tarafta bulunan gitflow eklentisini kullanarak repomuzu ilklendiriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/3.png)

- localde depoları takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/4.png)

- Şimdi `Git Flow` butonuna tıklayarak yeni bir feature oluşturuyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/5.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/6.png)

- localde takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/7.png)

- feature üzerinde değişiklik yapıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/8.png)

- Değişiklik `SourceTree` tool 'u tarafından algılandı.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/9.png)

- Commit edilecek dosyayı seçip `Add` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/10.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/11.png)

- `Commit` diyerek commitliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/12.png)

- `Git Flow` 'a tıklayarak mevcut feature 'ı kapatıyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/13.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/14.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/15.png)

- Açtığımız feature branch 'ını finish yaptığımız zaman yaptığımız eklemeler develop dalına merge ediliyor. Bu durumda Feature branch 'ını kapattıktan sonra develop dalında push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/16.png)

- Bitbucket 'a değişikliklerimiz gitmiş durumda.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/17.png)

- Şimdi geliştirmemizi developta tamamladık ve yeni bir versiyon çıkma zamanı geldi. `Git Flow` butonundan `Start new a Release` diyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/18.png)

- Ve versiyon numaramızı giriyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/19.png)

- localden takip edersek

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/20.png)

- Ve şimdi sadece bu release branch 'ını oluşturduktan sonra finish yaptığımız zaman develop dalındaki tüm çalışmalarımız master dalına merge olucaktır.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/21.png)

- Yeni versiyonumuz için minik bir açıklama ekliyoruz.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/22.png)

- localden takip edelim

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/23.png)

- Ancak şuanda develop brach 'ı sadece master 'a merge olmuş durumda bunu push yapmamız gerekmektedir.

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/24.png)

- Branch ve Tag 'lerimizin son durumu

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/25.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/26.png)

![İlk Aşama](https://raw.github.com/semihozkoroglu/File/master/gitflow/27.png)

- Kısaca amacımızı özetlemek gerekirse ana geliştirmemizi Develop dalında yapıyoruz. Ve Release edip master dalına geçirdiğimiz zaman aslında projemizin tamamen stabil olduğunu varsayıp bir versiyon tag 'i ekliyoruz. Develop dalında geliştirme yaparken ise projeyi parçalara ayırıp (veya bug, cr maddelerinin gelme durumunda) Feature brach 'ında tamamlayıp testinide yaptıktan sonra develop dalına merge işlemini yapıyoruz. Ve develop dalında geliştirdiğimiz proje mevcut özellikleri ile stabil duruma vardığında Release işlemini yapıyoruz. Master dalındaki projede bug bulunduğu zaman Hotfix branch 'ı açıp gerekli düzenlemeleri yaptıktan sonra kapatıldığında direk master 'a merge olucaktır.</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/Firstly we must pull linux installer of jira

`wget https://www.atlassian.com/software/jira/download`

Change permission of file for execute

`chmod a+x atlassian-jira-6.1-x64.bin`

And execute

`./atlassian-jira-6.1-x64.bin`

Now we will install apache for listen 80 port, because linux installer will create jira user and this user cannot access 80 port. But tomcat listening 8080 port and we must forward request to 8080 from 80. So we will install apache for open 80 port.

`sudo apt-get install apache2`

`sudo a2enmod proxy_http`

`sudo service apache2 start` // New configuration

Lets see opened port.

`netstat -ln`

And you can create virtual host on apache for forward but i want to select that use with iptables

`iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

For remove this rules

`iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

Lets see iptavbles rules

iptables -L" title="Firstly we must pull linux installer of jira

`wget https://www.atlassian.com/software/jira/download`

Change permission of file for execute

`chmod a+x atlassian-jira-6.1-x64.bin`

And execute

`./atlassian-jira-6.1-x64.bin`

Now we will install apache for listen 80 port, because linux installer will create jira user and this user cannot access 80 port. But tomcat listening 8080 port and we must forward request to 8080 from 80. So we will install apache for open 80 port.

`sudo apt-get install apache2`

`sudo a2enmod proxy_http`

`sudo service apache2 start` // New configuration

Lets see opened port.

`netstat -ln`

And you can create virtual host on apache for forward but i want to select that use with iptables

`iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

For remove this rules

`iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

Lets see iptavbles rules

iptables -L" class="label label-default">Firstly we must pull linux installer of jira

`wget https://www.atlassian.com/software/jira/download`

Change permission of file for execute

`chmod a+x atlassian-jira-6.1-x64.bin`

And execute

`./atlassian-jira-6.1-x64.bin`

Now we will install apache for listen 80 port, because linux installer will create jira user and this user cannot access 80 port. But tomcat listening 8080 port and we must forward request to 8080 from 80. So we will install apache for open 80 port.

`sudo apt-get install apache2`

`sudo a2enmod proxy_http`

`sudo service apache2 start` // New configuration

Lets see opened port.

`netstat -ln`

And you can create virtual host on apache for forward but i want to select that use with iptables

`iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

For remove this rules

`iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to 8080`

Lets see iptavbles rules

iptables -L</a>
	  
  
	  
	    <li><a href="/tag/" title="" class="label label-default"></a>
	  
	    <li><a href="/tag/if the theme you want to use the scrollbar entire application. We need to write custom theme. that ;

	<application
		.
		.
        android:theme="@style/AppTheme"
        .
        . >

and let's add scrollbar properties to sytles.xml

	<resources xmlns:android="http://schemas.android.com/apk/res/android">
	    <style name="AppTheme" parent="Theme.Sherlock.Light.NoActionBar">
	    	.
	    	.
	        <item name="android:scrollbarThumbVertical">@drawable/shape_scrollbar_style</item>
	        <item name="android:scrollbarSize">5dp</item>
	        .
	        .
	    </style>
 	</resources>


and now you can add what you want visuality to `drawable/shape_scrollbar_style.xml`

	<?xml version="1.0" encoding="utf-8"?>
	<shape xmlns:android="http://schemas.android.com/apk/res/android" >

	    <gradient
	        android:angle="45"
	        android:endColor="#103249"
	        android:startColor="#FF33B5E5" />

	    <corners android:radius="1dp" />

	    <stroke android:width="2dp"/>
	</shape>" title="if the theme you want to use the scrollbar entire application. We need to write custom theme. that ;

	<application
		.
		.
        android:theme="@style/AppTheme"
        .
        . >

and let's add scrollbar properties to sytles.xml

	<resources xmlns:android="http://schemas.android.com/apk/res/android">
	    <style name="AppTheme" parent="Theme.Sherlock.Light.NoActionBar">
	    	.
	    	.
	        <item name="android:scrollbarThumbVertical">@drawable/shape_scrollbar_style</item>
	        <item name="android:scrollbarSize">5dp</item>
	        .
	        .
	    </style>
 	</resources>


and now you can add what you want visuality to `drawable/shape_scrollbar_style.xml`

	<?xml version="1.0" encoding="utf-8"?>
	<shape xmlns:android="http://schemas.android.com/apk/res/android" >

	    <gradient
	        android:angle="45"
	        android:endColor="#103249"
	        android:startColor="#FF33B5E5" />

	    <corners android:radius="1dp" />

	    <stroke android:width="2dp"/>
	</shape>" class="label label-default">if the theme you want to use the scrollbar entire application. We need to write custom theme. that ;

	<application
		.
		.
        android:theme="@style/AppTheme"
        .
        . >

and let's add scrollbar properties to sytles.xml

	<resources xmlns:android="http://schemas.android.com/apk/res/android">
	    <style name="AppTheme" parent="Theme.Sherlock.Light.NoActionBar">
	    	.
	    	.
	        <item name="android:scrollbarThumbVertical">@drawable/shape_scrollbar_style</item>
	        <item name="android:scrollbarSize">5dp</item>
	        .
	        .
	    </style>
 	</resources>


and now you can add what you want visuality to `drawable/shape_scrollbar_style.xml`

	<?xml version="1.0" encoding="utf-8"?>
	<shape xmlns:android="http://schemas.android.com/apk/res/android" >

	    <gradient
	        android:angle="45"
	        android:endColor="#103249"
	        android:startColor="#FF33B5E5" />

	    <corners android:radius="1dp" />

	    <stroke android:width="2dp"/>
	</shape></a>
	  
  </li>
</ul>
          </section>
        </aside>
        <div class="twelve columns">
          <h2>Clonezilla'da karşılaştığım problem</h2>
<p class="meta">11 Dec 2010</p>

<div class="post">
<p>Endüstri labında clonezilla ile imajı alıp diğer bilgisayarlara sistemi kopyalıyordum.
Ancak iki tanesinde problemle karşılaştım.Şunu da belirtim sistemlerin hepsi aynı yani lenovanın
sıfır bilgisayarlar ancak bir tanesinde ekran bozuklugu var yani görüntü bios&#39;a girdiğimde de kötü ve sistemler açılırken
kilitleniyor.Bundaki durumu ekran kartı sıkıntılıdır şeklinde düşünmüştüm ama diğerindeki durum gerçekten ilginc
imajın bulundugu diskten başlattıgımda açılıyor ama kendi diskine kopyalamayı yaptıktan sonra windows açılırken logo&#39;da,
ubuntu ise siyah ekranda çakılıp kalıyor donanımsal bir problemin olması muhtemel.Bu durumun çözümünü buldugumda burada paylaşıcam.
Harici diskten başlattığımda açılıp kendi diskinden açılmamasının nedenini anlyabilirsem durum çözülmüş olur sanırım.</p>

<p>Bu yazımın altında devam ediyorum..İşletim sistemlerinin açlırken donmasının ve sadece güvenli modda açmasının sebebi
ekran kartı arızalı oldugundan dolayı imişş.Çünkü güvenli modda açabiliyorsa harddiskin sağlam olduğu ortada ve cd&#39;den kuruluma başlarkende aynı durumlarla
karşılaşınca ekran kartında problem olma olasılığı maximum dereceye ulaşmıştı.Basit bir denemeyle kendisini ele verdi zaten..</p>

</div>

<!-- Disqus start -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /*
   * var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread] 
   */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://19notlar.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Lütfen bu sayfaya gelen <a href="http://disqus.com/?ref_noscript=19notlar">yorumları</a> görmek için tarayıcınızın JavaScript desteğini etkinleştirin.</noscript>
<!-- Disqus end -->

        </div>
    </div>

    </section>

    <!-- Footer -->
    <footer id="footer">
      <!-- Bottom Footer -->
      <div id="footer-top">
        <div class="container">
          <div class="eight columns">
	Copyright © Sem 2013. All Rights Reserved.
</div>
<div >
	<ul class="footer-nav">
	  
	  <li>
	      <a href="https://github.com/semihozkoroglu">
	        <div class="icos-github">
	        </div>
	      </a>
	  </li>
	  
	  <li>
	      <a href="https://plus.google.com/105208314074645610795">
	        <div class="icos-google">
	        </div>
	      </a>
	  </li>
	  
	  <li>
	      <a href="https://www.facebook.com/semiiiih">
	        <div class="icos-facebook">
	        </div>
	      </a>
	  </li>
	  
	  <li>
	      <a href="http://www.linkedin.com/profile/view?id=181945022">
	        <div class="icos-linkedin">
	        </div>
	      </a>
	  </li>
	  
	  <li>
	      <a href="https://twitter.com/semihozkoroglu">
	        <div class="icos-twitter">
	        </div>
	      </a>
	  </li>
	  
	  <li>
	      <a href="http://www.youtube.com/channel/UCGMOH3R6gUxE9optqiSHUBw">
	        <div class="icos-youtube">
	        </div>
	      </a>
	  </li>
	  
</ul>
</div>

        </div>
      </div>
      <!-- END Bottom Footer -->

    </footer>
    <!-- END Footer -->

  </div>

</body>

</html>

</html>
